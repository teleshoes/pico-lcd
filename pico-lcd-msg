#!/usr/bin/perl
use strict;
use warnings;
use File::Basename qw(basename);

my $EXEC = basename $0;

my $DEVICE_CONFIG_FILE = "$ENV{HOME}/.config/pico-lcd.conf";

my $SPLIT_LINES_BIG_CHAR_LIMIT = 3000;

my $SPLIT_LINES_BIG_ONLY = "big-only";
my $SPLIT_LINES_ALWAYS = "always";
my $SPLIT_LINES_NEVER = "never";

my $DEFAULT_LCD_WIDTH = 240;
my $DEFAULT_LCD_HEIGHT = 240;

my $FONT_BASE_HEIGHT = 8;
my $FONT_BASE_WIDTH = 5;

my $USAGE = "Usage:
  $EXEC -h | --help
    show this message

  $EXEC [OPTS] --text=TEXT
    -parse IP_ADDRESS from $DEVICE_CONFIG_FILE
    -run: curl http://<IP_ADDRESS>/text --data 'TEXT'

  $EXEC [OPTS] WORD_OR_FILE [WORD_OR_FILE WORD_OR_FILE]
    -combine WORD_OR_FILE args into TEXT
      -if WORD_OR_FILE is a file:
        -append contents of WORD_OR_FILE to TEXT
      -otherwise:
        -replace '\\n' with literal newline in WORD_OR_FILE
        -if TEXT is not empty, append a space character
        -append ARG to TEXT
    -same as: $EXEC --text=TEXT

  $EXEC [OPTS] cmd   CMD [PARAM_NAME=PARAM_VAL PARAM_NAME=PARAM_VAL ..]
  $EXEC [OPTS] --cmd CMD [PARAM_NAME=PARAM_VAL PARAM_NAME=PARAM_VAL ..]
  $EXEC [OPTS] --cmd=CMD [PARAM_NAME=PARAM_VAL PARAM_NAME=PARAM_VAL ..]
    -parse IP_ADDRESS from $DEVICE_CONFIG_FILE
    -run: curl 'http://<IP_ADDRESS>/<CMD>?<PARAM_NAME>=<PARAM_VAL>&<PARAM_NAME>=<PARAM_VAL>'
        PARAM_NAME=PARAM_VAL
          pass in as URL param in curl
          PARAM_NAME and PARAM_VAL can contain only letters, numbers, and underscores

  $EXEC [OPTS] clear | --clear
    clear the LCD
      -same as: $EXEC [OPTS] --cmd clear

  $EXEC [OPTS] buttons | --buttons
    fetch button press counts and print them
      -same as: $EXEC [OPTS] --cmd buttons

  $EXEC [OPTS] orient   ORIENT
  $EXEC [OPTS] --orient ORIENT
  $EXEC [OPTS] --orient=ORIENT
    set the rotation
      -same as: $EXEC [OPTS] --cmd orient orient=<ORIENT>
        ORIENT
          landscape | 0 | normal | default
            set rotation to 0 degrees
          portrait | 270 | -90
            set rotation to 270 degrees
          inverted-landscape | 180
            set rotation to 180 degrees
          inverted-portrait | 90
            set rotateion to 90 degrees

  OPTS
    -q | --quiet
      do not print messages sent with curl

    --ip=IP_ADDRESS
      use IP_ADDRESS in calls to curl
    --dev=DEV_NAME
      -parse contents of $DEVICE_CONFIG_FILE
      -find line that matches this device: DEV_NAME = IP_ADDRESS
      -same as: --ip=IP_ADDRESS
    --default-dev | --any-dev
      -parse contents of $DEVICE_CONFIG_FILE
      -find first line that matches any device: DEV_NAME = IP_ADDRESS
      -same as: --ip=IP_ADDRESS
      (this is the default)

    --clear-text
      when setting text, clear the screen first
        if multiple messages (e.g.: with --lines):
          send param clear=true for first message, clear=false for others
        otherwise:
          send param clear=true with text
       (this is the default)
    --no-clear-text | --no-clear
        always send clear=false with all text commands

    --color=COLOR
      prefix all TEXT with '!color=COLOR!'
    --size=SIZE
      prefix all TEXT with '!size=SIZE!'
        (this is the number of pixels per dot, in a 5-dot by 8-dot font)
      NOTE: the default is to calculate the largest SIZE that fits all characters
    --hspace=HSPACE
      prefix all TEXT with '!hspace=HSPACE!'
    --vspace=VSPACE
      prefix all TEXT with '!vspace=VSPACE!'
    --x=X
      prefix all TEXT with '!x=X!'
    --y=Y
      prefix all TEXT with '!y=Y!'

    --lcd-width=WIDTH_PX
      select a SIZE based on WIDTH_PX, HSPACE, and number of chars in longest line of TEXT
    --lcd-height=HEIGHT_PX
      select a SIZE based on HEIGHT_PX, VSPACE, and number of lines in TEXT

    --lines
      -split TEXT into lines, TEXT_LINE
      -for each TEXT_LINE:
        -calculate the OFFSET for each line
          -first line is OFFSET=0
          -add SIZE*8 for each subsequent line
          -assume SIZE=5 if not given
        -prefix each TEXT_LINE with '!y=OFFSET!'
        -treat TEXT_LINE as TEXT, and prefix with --color/--size/etc
        -run: curl http://<IP_ADDRESS>/text 'TEXT_LINE'
    --no-lines
      never split lines as in --lines
    --lines-big-only
      if TEXT is $SPLIT_LINES_BIG_CHAR_LIMIT chars or more:
        same as: --lines
      otherwise:
        same as: --no-lines
      (this is the default)
";

my $MODE_TEXT = "text";
my $MODE_CMD = "cmd";

sub main(@){
  my $mode = undef;
  my $ipAddr = undef;
  my $devName = undef;
  my $quiet = 0;

  my $text = "";
  my $isClearText = 1;
  my $splitLines = $SPLIT_LINES_BIG_ONLY;
  my $lcdWidthPx = $DEFAULT_LCD_WIDTH;
  my $lcdHeightPx = $DEFAULT_LCD_HEIGHT;
  my ($color, $size, $hspace, $vspace, $x, $y);

  my $cmd = undef;
  my @params;

  while(@_ > 0){
    my $arg = shift @_;
    if($arg =~ /^(-h|--help)$/){
      print $USAGE;
      exit 0;
    }elsif($arg =~ /^(-q|--quiet)$/){
      $quiet = 1;
    }elsif($arg =~ /^--text=(.+)$/ and not defined $mode){
      $text = $1;
      $mode = $MODE_TEXT;
    }elsif($arg =~ /^--ip=(.+)$/){
      $ipAddr = $1
    }elsif($arg =~ /^--dev=(\w+)$/){
      $devName = $1;
    }elsif($arg =~ /^(--default-dev|--any-dev)$/){
      $devName = undef;
    }elsif($arg =~ /^(--cmd|cmd)$/ and @_ > 0 and not defined $mode){
      $cmd = shift @_;
      $mode = $MODE_CMD;
      while(@_ > 0 and $_[0] =~ /^\w+=\w+$/){
        push @params, shift @_;
      }
    }elsif($arg =~ /^--cmd=(\w+)$/ and not defined $mode){
      $cmd = $1;
      $mode = $MODE_CMD;
      while(@_ > 0 and $_[0] =~ /^\w+=\w+$/){
        push @params, shift @_;
      }
    }elsif($arg =~ /^(--clear|clear)$/ and not defined $mode){
      $cmd = "clear";
      $mode = $MODE_CMD;
    }elsif($arg =~ /^(--clear-text)$/){
      $isClearText = 1;
    }elsif($arg =~ /^(--no-clear-text|--no-clear)$/){
      $isClearText = 0;
    }elsif($arg =~ /^(--buttons|buttons)$/ and not defined $mode){
      $cmd = "buttons";
      $mode = $MODE_CMD;
    }elsif($arg =~ /^(--orient|orient)$/ and @_ > 0 and not defined $mode){
      $cmd = "orient";
      $mode = $MODE_CMD;
      push @params, "orient=" . shift @_;
    }elsif($arg =~ /^--orient=(\w+)$/ and not defined $mode){
      $cmd = "orient";
      $mode = $MODE_CMD;
      push @params, "orient=$1";
    }elsif($arg =~ /^--lcd-width=(\d+)$/){
      $lcdWidthPx = $1;
    }elsif($arg =~ /^--lcd-height=(\d+)$/){
      $lcdHeightPx = $1;
    }elsif($arg =~ /^(--lines)$/){
      $splitLines = $SPLIT_LINES_ALWAYS;
    }elsif($arg =~ /^(--no-lines)$/){
      $splitLines = $SPLIT_LINES_NEVER;
    }elsif($arg =~ /^(--lines-big-only)$/){
      $splitLines = $SPLIT_LINES_BIG_ONLY;
    }elsif($arg =~ /^--color=(.+)$/){
      $color = $1;
    }elsif($arg =~ /^--size=(.+)$/){
      $size = $1;
    }elsif($arg =~ /^--hspace=(.+)$/){
      $hspace = $1;
    }elsif($arg =~ /^--vspace=(.+)$/){
      $vspace = $1;
    }elsif($arg =~ /^--x=(.+)$/){
      $x = $1;
    }elsif($arg =~ /^--y=(.+)$/){
      $y = $1;
    }elsif(-f $arg and (not defined $mode or $mode eq $MODE_TEXT)){
      open FH, "< $arg" or die "ERROR: could not read $arg\n$!\n";
      my $contents = join '', <FH>;
      close FH;
      $text .= $contents;
      $mode = $MODE_TEXT;
    }elsif(not defined $mode or $mode eq $MODE_TEXT){
      $text .= " " if $text ne "";
      $text .= $arg;
      $mode = $MODE_TEXT;
    }else{
      die "ERROR: unknown arg $arg\n";
    }
  }

  if(not defined $ipAddr){
    my @lines = `cat $DEVICE_CONFIG_FILE 2>/dev/null`;
    for my $line(@lines){
      if($line =~ /^\s*(\w+)\s*=\s*(\d+\.\d+\.\d+\.\d+)$/){
        my ($cfgDevName, $cfgDevIP) = ($1, $2);
        if(not defined $devName or (lc $devName eq lc $cfgDevName)){
          $ipAddr = $cfgDevIP;
          last;
        }
      }
    }
    if(not defined $ipAddr){
      my $dev = defined $devName ? $devName : "any dev";
      die "ERROR: could not find IP address for $dev in $DEVICE_CONFIG_FILE\n";
    }
  }

  $mode = $MODE_TEXT if not defined $mode;

  if($mode eq $MODE_CMD){
    my $paramsFmt = "";
    if(@params > 0){
      $paramsFmt = "?" . join "&", @params;
    }

    system "curl", "--no-progress-meter", "http://$ipAddr/$cmd$paramsFmt";
  }elsif($mode eq $MODE_TEXT){
    my $charsTotal = length $text;

    my $isLines;
    if($splitLines eq $SPLIT_LINES_ALWAYS){
      $isLines = 1;
    }elsif($splitLines eq $SPLIT_LINES_BIG_ONLY){
      $isLines = $charsTotal > $SPLIT_LINES_BIG_CHAR_LIMIT ? 1 : 0;
    }else{
      $isLines = 0;
    }

    #remove '\r' chars
    $text =~ s/\r\n/\n/g;
    $text =~ s/\r/\n/g;

    #replace '!n!' markup with newlines
    $text =~ s/&/&amp;/g;
    while($text =~ /!([^!]*)!/){
      my $cmd = $1;
      if($cmd eq "n"){
        $text =~ s/!$cmd!/\n/;
      }else{
        $text =~ s/!$cmd!/&exc;$cmd&exc;/;
      }
    }
    $text =~ s/&exc;/!/g;
    $text =~ s/&amp;/&/g;

    my @lines = split /\n/, $text;

    my $charsH = @lines;
    my $charsW = 0;
    for my $line(@lines){
      $charsW = length $line if length $line > $charsW;
    }
    $charsW = 1 if $charsW <= 1;
    $charsH = 1 if $charsH <= 1;

    $vspace = 1 if not defined $vspace;
    $hspace = 1 if not defined $hspace;

    #select the largest size that will fit all characters,
    #  vertically and horizontally,
    #  or 1 if they cannot fit
    if(not defined $size){
      my $hSize = int($lcdWidthPx / ($charsW*($FONT_BASE_WIDTH + $hspace)));
      my $vSize = int($lcdHeightPx / ($charsH*($FONT_BASE_HEIGHT + $vspace)));
      $size = $hSize < $vSize ? $hSize : $vSize;
      $size = 1 if $size < 1;
    }

    my @messages;
    if($isLines){
      my $height = ($FONT_BASE_HEIGHT+$vspace)*$size;
      my $offset = 0;
      for my $line(@lines){
        push @messages, "!x=0!!y=$offset!$line";
        $offset += $height;
      }
    }else{
      if(length $text > 0){
        @messages = ($text);
      }
    }

    @messages = grep {length $_ > 0} @messages;

    for(my $i=0; $i<@messages; $i++){
      my $msg = $messages[$i];
      $msg = "!size=$size!$msg" if defined $size;
      $msg = "!color=$color!$msg" if defined $color;
      $msg = "!hspace=$hspace!$msg" if defined $hspace and $hspace != 1.0;
      $msg = "!vspace=$vspace!$msg" if defined $vspace and $vspace != 1.0;
      $msg = "!x=$x!$msg" if defined $x;
      $msg = "!y=$y!$msg" if defined $y;

      print "$msg\n" unless $quiet;

      #clear() on the first message unless --no-clear
      my $clear = ($isClearText and $i == 0) ? "true" : "false";

      #do not show() until last message
      my $show = $i < $#messages ? "false" : "true";

      system "curl", "--no-progress-meter",
        "http://$ipAddr/text?clear=$clear&show=$show",
        "--data", "$msg";
    }
  }else{
    die "ERROR: unknown mode $mode\n";
  }
}

&main(@ARGV);
