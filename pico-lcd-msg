#!/usr/bin/perl
use strict;
use warnings;
use File::Basename qw(basename);

sub fetchWindowGeometry($$);
sub calculateMaxFontSize($$$);
sub runCurlCmd($$$$$$);
sub parseConfig($);

my $EXEC = basename $0;

my $DEVICE_CONFIG_FILE = "$ENV{HOME}/.config/pico-lcd.conf";
my @DEVICES = parseConfig($DEVICE_CONFIG_FILE);
my @DEVICE_NAMES = map {$$_{devName}} @DEVICES;
my @DEVICE_SYNS = (map {@{$$_{syns}}} @DEVICES);
my %DEVICE_IPS_BY_NAME = map {
  my $ip = $$_{devIP}; map {$_ => $ip} ($$_{devName}, @{$$_{syns}})
} @DEVICES;
my $DEVICE_NAME_REGEX = join "|", (@DEVICE_NAMES, @DEVICE_SYNS);

my @DEFAULT_MARKUP_TEXT_PARAMS = qw(clear=true show=true info=true);

my $DEFAULT_LCD_WIDTH = 240;
my $DEFAULT_LCD_HEIGHT = 240;

my $FONT_BASE_HEIGHT = 8;
my $FONT_BASE_WIDTH = 5;

my $CLOCK_MARKUP = ""
  . "[size=4][hr][n]"
  . "[color=green][size=8][rtc=%H:%M][n]"
  . "[color=white][hr][size=4][n]"
  . " [rtc=%H:%M:%S]"
;

my $TEMPLATE_SETS = {
  "default" => {
    "timeout"        => "",
    "wifi-waiting"   => "",
    "wifi-connected" => "",
    "ap-waiting"     => "",
    "ap-active"      => "",
  },
  "clock" => {
    "timeout" => ""
      . "[size=4][rtc=%Y-%m-%d][n]"
      . $CLOCK_MARKUP,
    "wifi-waiting" => ""
      . "[size=2]WAITING WIFI   [rtc=%Y-%m-%d][n]"
      . "[var=ssid][n]"
      . $CLOCK_MARKUP,
    "wifi-connected" => ""
      . "[size=2]CONNECTED      [rtc=%Y-%m-%d][n]"
      . "[var=ip][n]"
      . $CLOCK_MARKUP,
    "ap-waiting" => ""
      . "[size=2]AP WAITING     [rtc=%Y-%m-%d][n]"
      . "[var=ssid][n]"
      . $CLOCK_MARKUP,
    "ap-active" => ""
      . "[size=2]ssid=[var=ssid]  [rtc=%Y-%m-%d][n]"
      . "pw=[var=password]   [var=ip][n]"
      . $CLOCK_MARKUP,
  },
};

my $USAGE = "Usage:
  $EXEC -h | --help
    show this message

  $EXEC [OPTS] text   TEXT
  $EXEC [OPTS] --text TEXT
    -parse IP_ADDRESS from $DEVICE_CONFIG_FILE
    -calculate+prepend TEXT with [size] markup
    -set CLEAR to 'true'
    -otherwise:
      -run: curl 'http://<IP_ADDRESS>/text?clear=<CLEAR>&show=true' --data '<TEXT>'

  $EXEC [OPTS] WORD [WORD WORD]
    -NOTE: the first WORD cannot start with '-'
    -combine WORD args into TEXT
      -replace '\\n' with literal newline in WORD
      -if TEXT is not empty, append a space character
      -append ARG to TEXT
    -same as: $EXEC --text=TEXT

  $EXEC [OPTS] --template-set TEMPLATE_SET_NAME
    apply pre-configured set of markup templates
    TEMPLATE_SET_NAME: " . join(" | ", sort keys %$TEMPLATE_SETS) . "

  $EXEC [OPTS] cmd   CMD [PARAM_NAME=PARAM_VAL PARAM_NAME=PARAM_VAL ..]
  $EXEC [OPTS] --cmd CMD [PARAM_NAME=PARAM_VAL PARAM_NAME=PARAM_VAL ..]
    -parse IP_ADDRESS from $DEVICE_CONFIG_FILE
    -run: curl 'http://<IP_ADDRESS>/<CMD>?<PARAM_NAME>=<PARAM_VAL>&<PARAM_NAME>=<PARAM_VAL>'
        PARAM_NAME=PARAM_VAL
          pass in as URL param in curl
          PARAM_NAME and can contain only letters, numbers, and underscores

  $EXEC [OPTS] info | --info
    fetch+show current state
      -same as: $EXEC [OPTS] --cmd info

  $EXEC [OPTS] connect | --connect
    re-connect to wifi or setup access point
      -same as: $EXEC [OPTS] --cmd connect

  $EXEC [OPTS] ssid | --ssid SSID PASSWORD [TIMEOUT]
    append a network for next boot/connect
      formatted:
        'TIMEOUT,SSID = PASSWORD'
        or
        'SSID = PASSWORD'
      -same as: $EXEC [OPTS] --ssid ssid=SSID password=PASSWORD timeout=TIMEOUT

  $EXEC [OPTS] resetwifi | --resetwifi
    REMOVE all configured wifi network SSIDs for next boot/connect
      -same as: $EXEC [OPTS] --cmd resetwifi

  $EXEC [OPTS] template TEMPLATE_NAME [TEMPLATE_MARKUP]
    write \"TEMPLATE_MARKUP\" to state-template-TEMPLATE_NAME file
      TEMPLATE_NAME: timeout | wifi-waiting | wifi-connected | ap-waiting | ap-active
    if TEMPLATE_MARKUP is omitted, the default markup for that template is used
      -same as: $EXEC [OPTS] --template name=TZDATA_ZONE_NAME --data=TEMPLATE_MARKUP

  $EXEC [OPTS] timeout [TIMEOUT_MILLIS]
  $EXEC [OPTS] --timeout [TIMEOUT_MILLIS]
    write \"TIMEOUT_MILLIS\" to state-timeout file
      after TIMEOUT_MILLIS milliseconds of no network commands,
      clear LCD, set LCD text to 'timeout' template, and show LCD
    if TIMEOUT_MILLIS is omitted, the timeout is removed,
      and the socket blocks forever
      -same as: $EXEC [OPTS] --cmd timeout timeoutMillis=TIMEOUT_MILLIS

  $EXEC [OPTS] timezone [TZDATA_ZONE_NAME]
    write \"TZDATA_ZONENAME\" to state-timezone file
      used for DS3231 real-time-clock in [rtc] markup
      requires calculating and installing tzdata CSV in advance
    if TZDATA_ZONE_NAME is omitted, delete state-timezone file
      -same as: $EXEC [OPTS] --cmd timezone name=TZDATA_ZONE_NAME

  $EXEC [OPTS] rtc RTC_EPOCH
    set the DS3231 RTC epoch to RTC_EPOCH
      -same as: $EXEC [OPTS] --cmd rtc epoch=RTC_EPOCH

  $EXEC [OPTS] clear | --clear
    clear the entire LCD memory
      -same as: $EXEC [OPTS] --cmd clear

  $EXEC [OPTS] show | --show
    show the framebuffer, if any
      -same as: $EXEC [OPTS] --cmd show

  $EXEC [OPTS] buttons | --buttons
    fetch button press counts and print them
      -same as: $EXEC [OPTS] --cmd buttons

  $EXEC [OPTS] fill   COLOR
  $EXEC [OPTS] --fill COLOR
    fill the window with COLOR
      -same as: $EXEC [OPTS] --cmd fill color=<COLOR>
        COLOR
          one of: white black red green blue

  $EXEC [OPTS] lcd   NAME
  $EXEC [OPTS] --lcd NAME
    set the lcd model to NAME
      -same as: $EXEC [OPTS] --cmd lcd name=<LCD_NAME>
        LCD_NAME
          one of: 1_3 2_0

  $EXEC [OPTS] orient   ORIENT
  $EXEC [OPTS] --orient ORIENT
    set the rotation
      -same as: $EXEC [OPTS] --cmd orient orient=<ORIENT>
        ORIENT
          landscape | 0 | normal | default
            set rotation to 0 degrees
          portrait | 270 | -90
            set rotation to 270 degrees
          inverted-landscape | 180
            set rotation to 180 degrees
          inverted-portrait | 90
            set rotation to 90 degrees

  $EXEC [OPTS] framebuf   FRAMEBUF
  $EXEC [OPTS] --framebuf FRAMEBUF
    -same as: $EXEC [OPTS] --cmd framebuf framebuf=FRAMEBUF
        FRAMEBUF:
          <FB_W>x<FB_H>+<FB_X>+<FB_Y> = enable framebuf with WxH and offset (0, 0)
          <FB_W>x<FB_H> = same as <FB_W>x<FB_H>+0+0
          off           = disable the framebuf
          <FB_NAME>     = one of: full | left | right | top | bottom | square
          full          = same as <LCD_W>x<LCD_H>                      e.g.: 320x240
          left          = same as <HALF_LCD_W>x<LCD_H>                 e.g.: 160x240
          right         = same as <HALF_LCD_W>x<LCD_H>+<HALF_LCD_W>+0  e.g.: 160x240+160+0
          top           = same as <LCD_W>x<HALF_LCD_H>                 e.g.: 320x120
          bottom        = same as <LCD_W>x<HALF_LCD_H>+0+<HALF_LCD_H>  e.g.: 320x120+0+120
          square        = same as <LCD_H>x<LCD_H>                      e.g.: 240x240

        <LCD_W>:      320 for lcd=2_0 or 240 for lcd=1_3
        <LCD_H>:      240 for lcd=2_0 or 240 for lcd=1_3
        <HALF_LCD_W>: 160 for lcd=2_0 or 120 for lcd_1_3
        <HALF_LCD_H>: 120 for lcd_2_0 or 120 for lcd_1_3

        NOTE: 'framebuf' param is *unaffected* by orientation
              <FB_W> and <FB_X> always refer to the longest dimension of the physical LCD
              <FB_H> and <FB_Y> always refer to the shortest dimension of the physical LCD
        NOTE: 'framebuf' uses a lot of memory. if memory allocation fails, framebuf is disabled
              the framebuf, if any, that is actually successfully allocated is returned
              if 'framebuf: off' is returned instead of a framebuf, allocation likely failed

  $EXEC [OPTS] upload   FILE [DEST_FILENAME]
  $EXEC [OPTS] --upload FILE [DEST_FILENAME]
    upload file FILE to DEST_FILENAME (DEST_FILENAME defaults to FILE if omitted)
    -same as:
      $EXEC [OPTS] --cmd upload filename=DEST_FILENAME --upload-file=FILE

  $EXEC [OPTS] delete   FILENAME
  $EXEC [OPTS] --delete FILENAME
    delete remote file FILENAME
    -same as: $EXEC [OPTS] --cmd delete filename=FILENAME

  $EXEC [OPTS] bootloader | --bootloader | bootsel | --bootsel
    enter bootloader (bootsel mass storage mode)
    also sets curl --max-time to 3s, as it will hang forever otherwise
      -same as: $EXEC [OPTS] --cmd bootloader -m 3


  OPTS
    -q | --quiet
      do not print messages sent with curl

    -m CURL_MAX_TIME_FRAC_SECONDS
    --max-time CURL_MAX_TIME_FRAC_SECONDS
    --max-time=CURL_MAX_TIME_FRAC_SECONDS
      pass '--max-time CURL_MAX_TIME_FRAC_SECONDS' to all calls to curl

    --data DATA | --data=DATA
    --body DATA | --body=DATA
      for --cmd, pass in DATA as POST payload with curl (using '--data DATA')
    --upload-file=FILENAME
      for --cmd, pass in FILENAME contents as PUT payload with curl
      (using '--upload-file' FILENAME)

    --ip=IP_ADDRESS
      use IP_ADDRESS in calls to curl
    --ap
      use IP_ADDRESS=192.168.4.1
    DEV_NAME | --dev=DEV_NAME | --dev DEV_NAME
    DEV_NAME | --dev=DEV_NAME | --dev DEV_NAME
      -parse contents of $DEVICE_CONFIG_FILE
         -each entry is a single line that contains:
           <CONF_DEV_NAME>, <IP_ADDRESS>, and optional space-separated <SYN_NAME> list
         -each element is separated by a comma or equals sign
         -i.e.:
           CONF_DEV_NAME = IP_ADDRESS
           CONF_DEV_NAME, IP_ADDRESS
           CONF_DEV_NAME, IP_ADDRESS, [SYN_NAME SYN_NAME SYN_NAME...]
      -find the first line where DEV_NAME equals CONF_DEV_NAME or SYN_NAME
        -select the IP_ADDRESS for that entry
      -same as: --ip=IP_ADDRESS
        DEV_NAME
          one of: $DEVICE_NAME_REGEX
    --default-dev | --any-dev
      -select the IP_ADDRESS of the first CONF_DEV_NAME in $DEVICE_CONFIG_FILE
      (this is the default)
";

my $MODE_TEXT = "text";
my $MODE_CMD = "cmd";
my $MODE_TEMPLATE_SET = "template-set";

sub main(@){
  my $mode = undef;
  my $ipAddr = undef;
  my $devName = undef;
  my $quiet = 0;
  my $curlMaxTime = undef;

  my $text = "";

  my $templateSet = undef;

  my $cmd = undef;
  my @cmdParams;
  my $cmdData = undef;
  my $cmdFile = undef;

  while(@_ > 0){
    my $arg = shift @_;
    if($arg =~ /^(-h|--help)$/){
      print $USAGE;
      exit 0;
    }elsif($arg =~ /^(-q|--quiet)$/){
      $quiet = 1;
    }elsif($arg =~ /^(-m|--max-time)$/ and @_ > 0 and $_[0] =~ /^(\d+|\d*\.\d+)$/){
      $curlMaxTime = shift @_;
    }elsif($arg =~ /^(?:--max-time)=(\d+|\d*\.\d+)$/){
      $curlMaxTime = $1;
    }elsif($arg =~ /^--ip=(.+)$/){
      $ipAddr = $1
    }elsif($arg =~ /^(--ap)$/){
      $ipAddr = '192.168.4.1';
    }elsif($arg =~ /^--dev=(\w+)$/){
      $devName = $1;
    }elsif($arg =~ /^--dev$/ and @_ > 0 and $_[0] =~ /^(\w+)$/){
      $devName = shift @_;
    }elsif($arg =~ /^($DEVICE_NAME_REGEX)$/){
      $devName = $1;
    }elsif($arg =~ /^(--default-dev|--any-dev)$/){
      $devName = undef;
    }elsif($arg =~ /^(--text|text)$/ and @_ > 0 and not defined $mode){
      $text = shift @_;
      $mode = $MODE_TEXT;
    }elsif($arg =~ /^(--template-set|template-set)$/ and @_ > 0 and not defined $mode){
      $templateSet = shift @_;
      if(not defined $$TEMPLATE_SETS{$templateSet}){
        die "ERROR: unknown template set $templateSet\n";
      }
      $mode = $MODE_TEMPLATE_SET;
    }elsif($arg =~ /^(--cmd|cmd)$/ and @_ > 0 and not defined $mode){
      $cmd = shift @_;
      $mode = $MODE_CMD;
      while(@_ > 0 and $_[0] =~ /^\w+=.+$/){
        push @cmdParams, shift @_;
      }
    }elsif($arg =~ /^(--data|--body)$/ and @_ > 0){
      $cmdData = shift @_;
      die "ERROR: --data must follow --cmd\n" if $mode ne $MODE_CMD;
    }elsif($arg =~ /^(?:--data|--body)=(.+)$/s){
      $cmdData = $1;
      die "ERROR: --data must follow --cmd\n" if $mode ne $MODE_CMD;
    }elsif($arg =~ /^--upload-file=(.+)$/){
      $cmdFile = $1;
      die "ERROR: --upload-file must follow --cmd\n" if $mode ne $MODE_CMD;
    }elsif($arg =~ /^(--info|info)$/ and not defined $mode){
      $cmd = "info";
      $mode = $MODE_CMD;
    }elsif($arg =~ /^(--connect|connect)$/ and not defined $mode){
      $cmd = "connect";
      $mode = $MODE_CMD;
    }elsif($arg =~ /^(--ssid|ssid)$/ and @_ >= 2 and not defined $mode){
      $cmd = "ssid";
      $mode = $MODE_CMD;
      push @cmdParams, "ssid=" . shift @_;
      push @cmdParams, "password=" . shift @_;
      if(@_ > 0){
        push @cmdParams, "timeout=" . shift @_;
      }
    }elsif($arg =~ /^(--resetwifi|resetwifi)$/ and not defined $mode){
      $cmd = "resetwifi";
      $mode = $MODE_CMD;
    }elsif($arg =~ /^(--template|template)$/ and not defined $mode){
      $cmd = "template";
      $mode = $MODE_CMD;
    }elsif($arg =~ /^(--timeout|timeout)$/ and not defined $mode){
      $cmd = "timeout";
      $mode = $MODE_CMD;
    }elsif($arg =~ /^(--timezone|timezone)$/ and not defined $mode){
      $cmd = "timezone";
      $mode = $MODE_CMD;
    }elsif($arg =~ /^(--rtc|rtc)$/ and not defined $mode){
      $cmd = "rtc";
      $mode = $MODE_CMD;
    }elsif($arg =~ /^(--clear|clear)$/ and not defined $mode){
      $cmd = "clear";
      $mode = $MODE_CMD;
    }elsif($arg =~ /^(--show|show)$/ and not defined $mode){
      $cmd = "show";
      $mode = $MODE_CMD;
    }elsif($arg =~ /^(--buttons|buttons)$/ and not defined $mode){
      $cmd = "buttons";
      $mode = $MODE_CMD;
    }elsif($arg =~ /^(--fill|fill)$/ and @_ > 0 and not defined $mode){
      $cmd = "fill";
      $mode = $MODE_CMD;
      push @cmdParams, "color=" . shift @_;
    }elsif($arg =~ /^(--lcd|lcd)$/ and @_ > 0 and not defined $mode){
      $cmd = "lcd";
      $mode = $MODE_CMD;
      push @cmdParams, "name=" . shift @_;
    }elsif($arg =~ /^(--orient|orient)$/ and @_ > 0 and not defined $mode){
      $cmd = "orient";
      $mode = $MODE_CMD;
      push @cmdParams, "orient=" . shift @_;
    }elsif($arg =~ /^(--framebuf|framebuf)$/ and @_ > 0 and not defined $mode){
      $cmd = "framebuf";
      $mode = $MODE_CMD;
      push @cmdParams, "framebuf=" . shift @_;
    }elsif($arg =~ /^(--upload|upload)$/ and @_ > 0 and not defined $mode){
      $cmd = "upload";
      $mode = $MODE_CMD;
      $cmdFile = shift @_;
      my $destFilename = $cmdFile;
      if(@_ > 0){
        $destFilename = shift @_;
      }
      push @cmdParams, "filename=$destFilename";
    }elsif($arg =~ /^(--delete|delete)$/ and @_ > 0 and not defined $mode){
      $cmd = "delete";
      $mode = $MODE_CMD;
      push @cmdParams, "filename=" . shift @_;
    }elsif($arg =~ /^(--bootloader|bootloader|--bootsel|bootsel)$/ and not defined $mode){
      $cmd = "bootloader";
      $mode = $MODE_CMD;
      $curlMaxTime = 3;
    }elsif((defined $mode and $mode eq $MODE_TEXT) or ($arg !~ /^-/ and not defined $mode)){
      $text .= " " if $text ne "";
      $text .= $arg;
      $mode = $MODE_TEXT;
    }elsif((defined $cmd and $cmd eq "template") and @cmdParams == 0){
      push @cmdParams, "templateName=$arg";
    }elsif((defined $cmd and $cmd eq "template") and @cmdParams == 1 and not defined $cmdData){
      $cmdData = $arg;
    }elsif((defined $cmd and $cmd eq "timeout") and @cmdParams == 0){
      push @cmdParams, "timeoutMillis=$arg";
    }elsif((defined $cmd and $cmd eq "timezone") and @cmdParams == 0){
      push @cmdParams, "name=$arg";
    }elsif((defined $cmd and $cmd eq "rtc") and @cmdParams == 0){
      push @cmdParams, "epoch=$arg";
    }else{
      die "ERROR: unknown arg $arg\n";
    }
  }

  if(not defined $ipAddr){
    if(not defined $devName){
      die "ERROR: no devices configured\n" if @DEVICE_NAMES == 0;
      $devName = $DEVICE_NAMES[0];
    }

    $ipAddr = $DEVICE_IPS_BY_NAME{lc $devName};
    if(not defined $ipAddr){
      die "ERROR: could not find IP address for $devName in $DEVICE_CONFIG_FILE\n";
    }
  }

  $mode = $MODE_TEXT if not defined $mode;

  my @curlOpts = ("--no-progress-meter");
  @curlOpts = (@curlOpts, "--max-time", $curlMaxTime) if defined $curlMaxTime;

  if($mode eq $MODE_CMD){
    runCurlCmd(\@curlOpts, $ipAddr, $cmd, \@cmdParams, $cmdData, $cmdFile);
  }elsif($mode eq $MODE_TEXT){
    #select the largest size that will fit all characters,
    #  vertically and horizontally,
    #  or 1 if they cannot fit

    my ($windowWidthPx, $windowHeightPx) = fetchWindowGeometry($ipAddr, [@curlOpts]);
    my $size = calculateMaxFontSize($text, $windowWidthPx, $windowHeightPx);

    my $msg = $text;
    $msg = "[size=$size]$msg" if defined $size;

    print "$msg\n" unless $quiet;

    my @params = @DEFAULT_MARKUP_TEXT_PARAMS;

    runCurlCmd(\@curlOpts, $ipAddr, "text", \@params, $msg, undef);
  }elsif($mode eq $MODE_TEMPLATE_SET){
    my $set = $$TEMPLATE_SETS{$templateSet};
    for my $templateName(sort keys %$set){
      my $markup = $$set{$templateName};
      runCurlCmd(\@curlOpts, $ipAddr, "template", ["templateName=$templateName"], $markup, undef);
    }
  }else{
    die "ERROR: unknown mode $mode\n";
  }
}

sub fetchWindowGeometry($$){
  my ($ipAddr, $curlOpts) = @_;
  my $info = `curl @$curlOpts 'http://$ipAddr/info'`;
  if($info =~ /window:\s+(\d+)x(\d+)/){
    return ($1, $2);
  }else{
    return ($DEFAULT_LCD_WIDTH, $DEFAULT_LCD_HEIGHT);
  }
}

sub calculateMaxFontSize($$$){
  my ($markup, $windowWidthPx, $windowHeightPx) = @_;
  my $text = $markup;

  #remove '\r' chars
  $text =~ s/\r\n/\n/g;
  $text =~ s/\r/\n/g;

  #replace '[[' literals with '[bracket]'
  $text =~ s/\[\[/\[bracket\]/g;

  #replace '[n]' markup wih literal '\n'
  $text =~ s/\[n\]/\n/g;

  my @lines = split /\n/, $text;

  my $charsH = @lines;
  my $charsW = 0;
  for my $line(@lines){
    $charsW = length $line if length $line > $charsW;
  }
  $charsW = 1 if $charsW <= 1;
  $charsH = 1 if $charsH <= 1;

  my $vspace = 1;
  my $hspace = 1;

  my $hSize = int($windowWidthPx / ($charsW*($FONT_BASE_WIDTH + $hspace)));
  my $vSize = int($windowHeightPx / ($charsH*($FONT_BASE_HEIGHT + $vspace)));
  my $size = $hSize < $vSize ? $hSize : $vSize;
  $size = 1 if $size < 1;

  return $size;
}

sub runCurlCmd($$$$$$){
  my ($curlOpts, $ipAddr, $cmd, $cmdParams, $cmdData, $cmdFile) = @_;
  my $paramsFmt = "";
  if(@$cmdParams > 0){
    $paramsFmt = "?" . join "&", @$cmdParams;
  }

  my @curlCmd = ("curl", @$curlOpts, "http://$ipAddr/$cmd$paramsFmt");
  @curlCmd = (@curlCmd, "--data", $cmdData) if defined $cmdData;
  @curlCmd = (@curlCmd, "--upload-file", $cmdFile) if defined $cmdFile;
  system @curlCmd;
}

sub parseConfig($){
  my @devices;
  my @lines = `cat $DEVICE_CONFIG_FILE 2>/dev/null`;
  my $sep = '(?:\s*[=,]\s*)';
  for my $line(@lines){
    if($line =~ /^\s*([0-9a-zA-Z_\-]+)$sep(\d+\.\d+\.\d+\.\d+)(?:$sep(.*))?$/){
      my ($devName, $devIP, $synStr) = ($1, $2, $3);
      $synStr = "" if not defined $synStr;
      my @syns = split /\s+/, $synStr;
      @syns = grep {$_ =~ /^\w+$/} @syns;
      push @devices, {devName => $devName, devIP => $devIP, syns => [@syns]};
    }
  }
  return @devices;
}

&main(@ARGV);
